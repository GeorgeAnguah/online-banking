package com.onlinebanking.shared.util;

import com.onlinebanking.enums.ErrorMessage;
import com.onlinebanking.excepton.EncryptionException;
import com.onlinebanking.shared.util.validation.InputValidationUtils;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.security.auth.Destroyable;
import java.lang.reflect.Field;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

/**
 * This class provides mechanism to encrypt and decrypt a text.
 *
 * @author Eric Opoku
 * @version 1.0
 * @since 1.0
 */
@Slf4j
public final class EncryptionUtils {

    private static final String ERROR_ENCRYPTING_DATA = "Error encrypting data";
    private static final String ERROR_DECRYPTING_DATA = "Error decrypting data";

    private static final int GCM_TAG_LENGTH = 128; // bits
    public static final String SIZE_OF_KEY_INVALID_MESSAGE = "Size of key must be 128, 192 or 256";

    // NIST recommendation: "For IVs, it is recommended that implementations
    // restrict support to the length of 96 bits, to
    // promote interoperability, efficiency, and simplicity of design."
    private static final int IV_LEN = 12; // bytes

    // number of random number bytes generated before re-seeding
    private static final double PRNG_RESEED_INTERVAL = Math.pow(2, 16);
    private static final String ENCRYPT_ALGORITHM = "AES/GCM/NoPadding";
    private static final List<Integer> ALLOWED_KEY_SIZES = Arrays.asList(128, 192, 256); // bits

    private static SecureRandom prng;

    // Used to keep track of random number bytes generated by PRNG
    // (for the purpose of re-seeding)
    private static int bytesGenerated;

    private EncryptionUtils() {
        throw new AssertionError(ErrorMessage.NOT_INSTANTIABLE.getErrorMsg());
    }

    /**
     * Encrypts the text provided.
     *
     * @param text the text to encrypt
     * @param key  the secretKeySpec
     *
     * @return the encrypted byte array
     */
    public static byte[] encrypt(byte[] text, SecretKeySpec key) {
        return encrypt(text, key, ENCRYPT_ALGORITHM);
    }

    /**
     * Encrypts the text provided.
     *
     * @param text      the text to encrypt
     * @param key       the secretKeySpec
     * @param algorithm the algorithm
     *
     * @return the encrypted byte array
     */
    public static byte[] encrypt(byte[] text, SecretKeySpec key, String algorithm) {
        InputValidationUtils.validateInputs(text, key);

        try {
            validateKey(key);
            Cipher cipher = Cipher.getInstance(algorithm);

            byte[] iv = generateIv(IV_LEN);
            GCMParameterSpec gcmParamSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, gcmParamSpec);
            byte[] messageCipher = cipher.doFinal(text);

            // Prepend the IV with the message cipher
            byte[] cipherText = new byte[messageCipher.length + IV_LEN];
            System.arraycopy(iv, 0, cipherText, 0, IV_LEN);
            System.arraycopy(messageCipher, 0, cipherText, IV_LEN, messageCipher.length);

            return cipherText;
        } catch (NoSuchAlgorithmException
                | InvalidKeyException
                | InvalidAlgorithmParameterException
                | IllegalBlockSizeException
                | BadPaddingException
                | NoSuchPaddingException e) {
            LOG.debug(ERROR_ENCRYPTING_DATA, e);
            throw new EncryptionException(e);
        }
    }

    /**
     * Decrypts the encryptedText provided.
     *
     * @param encryptedText the encryptedText to decrypt
     * @param key           the secretKeySpec
     *
     * @return the decrypted byte array
     */
    public static byte[] decrypt(byte[] encryptedText, SecretKeySpec key) {
        return decrypt(encryptedText, key, ENCRYPT_ALGORITHM);
    }

    /**
     * Decrypts the encryptedText provided.
     *
     * @param encryptedText the encryptedText to decrypt
     * @param key           the secretKeySpec
     * @param algorithm     the algorithm
     *
     * @return the decrypted byte array
     */
    public static byte[] decrypt(byte[] encryptedText, SecretKeySpec key, String algorithm) {
        InputValidationUtils.validateInputs(encryptedText, key);

        try {
            byte[] iv = new byte[IV_LEN];
            System.arraycopy(encryptedText, 0, iv, 0, IV_LEN);

            byte[] messageCipher = new byte[encryptedText.length - IV_LEN];
            System.arraycopy(encryptedText, IV_LEN, messageCipher, 0, encryptedText.length - IV_LEN);
            GCMParameterSpec gcmParamSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);

            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, key, gcmParamSpec);

            return cipher.doFinal(messageCipher);
        } catch (NoSuchAlgorithmException
                | InvalidKeyException
                | InvalidAlgorithmParameterException
                | IllegalBlockSizeException
                | BadPaddingException
                | NoSuchPaddingException e) {
            LOG.debug(ERROR_DECRYPTING_DATA, e);
            throw new EncryptionException(e);
        }
    }

    /**
     * Generates an iv with the number of bytes specified.
     *
     * @param bytesNum the number of bytes
     *
     * @return the iv
     */
    public static byte[] generateIv(int bytesNum) {

        if (bytesNum < 1) {
            throw new IllegalArgumentException("Number of bytes must be greater than 0");
        }

        byte[] iv = new byte[bytesNum];
        Optional.ofNullable(prng).orElseGet(() -> { //NOSONAR
            try {
                prng = SecureRandom.getInstanceStrong();
            } catch (NoSuchAlgorithmException e) {
                throw new EncryptionException("Wrong algorithm name", e);
            }
            return prng;
        });

        if (bytesGenerated > PRNG_RESEED_INTERVAL || bytesGenerated == 0) {
            prng.setSeed(prng.generateSeed(bytesNum));
            bytesGenerated = 0;
        }
        prng.nextBytes(iv);
        bytesGenerated = bytesGenerated + bytesNum;

        return iv;
    }

    /**
     * Clears the SecretKeySpec.
     *
     * @param key the secretKeySpec
     */
    public static void clearSecret(Destroyable key) {
        try {
            Field keyField = key.getClass().getDeclaredField("key");
            keyField.setAccessible(true); //NOSONAR
            byte[] encodedKey = (byte[]) keyField.get(key);
            Arrays.fill(encodedKey, Byte.MIN_VALUE);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new EncryptionException(e);
        }
    }

    /**
     * Validates the secret key provided.
     *
     * @param key the secret key
     */
    private static void validateKey(SecretKeySpec key) {

        if (!ALLOWED_KEY_SIZES.contains(key.getEncoded().length * 8)) {
            throw new IllegalArgumentException(SIZE_OF_KEY_INVALID_MESSAGE);
        }
    }

}
